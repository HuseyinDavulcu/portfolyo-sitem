<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Smart Konteyner Planlayıcı</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js ve OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Google Fonts & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        
        /* Scrollbar düzenlemeleri */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Sürükle bırak stilleri */
        .draggable-item { cursor: grab; transition: all 0.2s; user-select: none; }
        .draggable-item:active { cursor: grabbing; transform: scale(1.02); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); z-index: 50; }
        .dragging { opacity: 0.5; border: 2px dashed #3b82f6; background-color: #eff6ff; }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #e2e8f0 0%, #cbd5e1 100%);
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-size: 0.8rem;
            color: #475569;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-slate-800 text-white p-3 shadow-md flex justify-between items-center z-20 h-14">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-cubes-stacked text-2xl text-emerald-400"></i>
            <h1 class="text-lg font-bold">Smart Load Planner</h1>
        </div>
        <div class="flex gap-3 text-sm font-medium">
             <div class="bg-slate-700 px-3 py-1 rounded">
                <i class="fa-solid fa-weight-hanging text-slate-400 mr-1"></i>
                <span id="total-weight-display">0 kg</span>
             </div>
             <div class="bg-slate-700 px-3 py-1 rounded">
                <i class="fa-solid fa-ruler-combined text-slate-400 mr-1"></i>
                <span id="total-vol-display">0 m³</span>
             </div>
             <div class="bg-slate-700 px-3 py-1 rounded">
                <i class="fa-solid fa-percent text-slate-400 mr-1"></i>
                <span id="fill-rate-display">%0 Doluluk</span>
             </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        
        <!-- SOL PANEL: Veri Girişi -->
        <aside class="w-80 bg-white border-r border-slate-200 flex flex-col shadow-lg z-10 overflow-hidden">
            <div class="p-4 border-b border-slate-100 bg-slate-50">
                <h2 class="font-semibold text-slate-700 mb-3 flex items-center gap-2 text-sm">
                    <i class="fa-solid fa-warehouse text-blue-600"></i> Konteyner Tipi
                </h2>
                <select id="container-select" class="w-full p-2 bg-white border border-slate-300 rounded focus:ring-2 focus:ring-blue-500 outline-none text-sm shadow-sm">
                    <option value="20dc">20' DC (5.9m x 2.35m x 2.39m)</option>
                    <option value="40hc">40' HC (12m x 2.35m x 2.69m)</option>
                    <option value="truck">Standart Tır (13.6m x 2.45m x 2.6m)</option>
                </select>
            </div>

            <div class="p-4 flex-1 overflow-y-auto custom-scroll">
                <h2 class="font-semibold text-slate-700 mb-3 flex items-center gap-2 text-sm">
                    <i class="fa-solid fa-box-open text-blue-600"></i> Yük Tanımla
                </h2>
                
                <form id="add-item-form" class="space-y-3">
                    <div>
                        <label class="text-xs font-semibold text-slate-500 uppercase tracking-wider block mb-1">Ürün Tanımı</label>
                        <input type="text" id="p-name" placeholder="Örn: Euro Palet A" class="w-full p-2 border border-slate-300 rounded text-sm focus:border-blue-500 outline-none" required>
                    </div>

                    <div class="grid grid-cols-3 gap-2">
                        <div>
                            <label class="text-xs text-slate-500 block mb-1 text-center">En (cm)</label>
                            <input type="number" id="p-width" value="80" class="w-full p-2 border border-slate-300 rounded text-center text-sm" required>
                        </div>
                        <div>
                            <label class="text-xs text-slate-500 block mb-1 text-center">Boy (cm)</label>
                            <input type="number" id="p-length" value="120" class="w-full p-2 border border-slate-300 rounded text-center text-sm" required>
                        </div>
                        <div>
                            <label class="text-xs text-slate-500 block mb-1 text-center">Yük (cm)</label>
                            <input type="number" id="p-height" value="100" class="w-full p-2 border border-slate-300 rounded text-center text-sm" required>
                        </div>
                    </div>

                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="text-xs font-semibold text-slate-500 uppercase tracking-wider block mb-1">Ağırlık (kg)</label>
                            <input type="number" id="p-weight" value="500" class="w-full p-2 border border-slate-300 rounded text-sm" required>
                        </div>
                        <div>
                            <label class="text-xs font-semibold text-slate-500 uppercase tracking-wider block mb-1">Adet</label>
                            <input type="number" id="p-count" value="1" min="1" max="100" class="w-full p-2 border border-slate-300 rounded text-sm font-bold text-blue-600">
                        </div>
                    </div>

                    <div class="flex items-center gap-3 pt-1">
                        <input type="color" id="p-color" value="#3b82f6" class="h-8 w-12 p-0 border-0 rounded cursor-pointer shadow-sm">
                        <span class="text-xs text-slate-400">Görünüm Rengi</span>
                    </div>
                    
                    <div class="flex items-center gap-2 mt-2">
                        <input type="checkbox" id="allow-rotation" checked class="w-4 h-4 text-blue-600 rounded">
                        <label for="allow-rotation" class="text-xs text-slate-600">Paletler Döndürülebilir (Daha iyi sığması için)</label>
                    </div>

                    <button type="submit" class="w-full bg-slate-800 hover:bg-slate-900 text-white font-medium py-2.5 rounded shadow-sm transition-all hover:shadow-md flex justify-center items-center gap-2 mt-2">
                        <i class="fa-solid fa-plus-circle"></i> Ekle
                    </button>
                </form>

                <div class="mt-6 p-3 bg-blue-50 rounded border border-blue-100 text-xs text-blue-800">
                    <p class="font-bold mb-1"><i class="fa-solid fa-circle-info"></i> Tetris Modu:</p>
                    <p>Artık küçük kutuları listenin üstüne taşıdığınızda, algoritma arkadaki ve alttaki boşlukları arayıp oraya yerleştirecektir.</p>
                </div>
            </div>
        </aside>

        <!-- ORTA PANEL: Liste & Kontroller -->
        <div class="w-80 bg-slate-50 border-r border-slate-200 flex flex-col z-10">
            <div class="p-3 border-b border-slate-200 bg-white flex justify-between items-center shadow-sm">
                <h2 class="font-semibold text-slate-700 text-sm">Yükleme Listesi</h2>
                <button id="clear-list" class="text-xs text-red-500 hover:text-red-700 hover:underline px-2">Temizle</button>
            </div>
            
            <div id="items-list-container" class="flex-1 overflow-y-auto p-2 space-y-2 custom-scroll bg-slate-100">
                <div class="text-center text-slate-400 mt-10 text-sm flex flex-col items-center gap-2">
                    <i class="fa-solid fa-clipboard-list text-2xl opacity-20"></i>
                    <span>Liste boş.</span>
                </div>
            </div>
            
            <div class="p-3 bg-white border-t border-slate-200 space-y-2 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                <button onclick="autoOptimize()" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-2 rounded font-medium text-sm transition-colors flex items-center justify-center gap-2 shadow-sm group">
                    <i class="fa-solid fa-wand-magic-sparkles group-hover:rotate-12 transition-transform"></i>
                    Otomatik Optimize Et
                </button>
                <div class="text-[10px] text-center text-slate-400">
                    Kutuların sırasını değiştirmek için sürükleyin. Üsttekiler önce yerleşir.
                </div>
            </div>
        </div>

        <!-- SAĞ PANEL: 3D Görünüm -->
        <main class="flex-1 relative bg-slate-200 overflow-hidden">
            <!-- 3D Overlay Controls -->
            <div class="absolute top-4 left-4 z-10 flex flex-col gap-2">
                <div class="stat-card">
                    <i class="fa-solid fa-cube text-blue-500"></i> <span id="placed-count">0</span> / <span id="total-count">0</span> Kutu Yerleşti
                </div>
                <div class="stat-card text-xs">
                   <p class="mb-1"><strong>Kontroller:</strong></p>
                   <p>Sol Tık: Döndür</p>
                   <p>Sağ Tık: Kaydır</p>
                   <p>Tekerlek: Yakınlaş</p>
                </div>
            </div>

            <!-- Kullanıcı Mesajları -->
            <div id="status-message" class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white px-4 py-2 rounded-full shadow-lg text-sm font-medium z-10 opacity-0 transition-opacity pointer-events-none">
                İşlem tamamlandı
            </div>

            <div id="canvas-container"></div>
        </main>

    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        // --- CONFIG & STATE ---
        const containerTypes = {
            '20dc': { name: "20' DC", w: 235, h: 239, l: 589, maxWeight: 28000 },
            '40hc': { name: "40' HC", w: 235, h: 269, l: 1203, maxWeight: 28500 },
            'truck': { name: "Standart Tır", w: 245, h: 260, l: 1360, maxWeight: 24000 }
        };

        let currentContainer = containerTypes['20dc'];
        let items = []; // Tüm ürünler
        let placedItems = []; // Yerleşebilenler {x,y,z,w,h,l, color}
        let dragStartIndex;

        // --- DOM ELEMENTS ---
        const ui = {
            containerSelect: document.getElementById('container-select'),
            addItemForm: document.getElementById('add-item-form'),
            listContainer: document.getElementById('items-list-container'),
            weightDisplay: document.getElementById('total-weight-display'),
            volDisplay: document.getElementById('total-vol-display'),
            fillDisplay: document.getElementById('fill-rate-display'),
            placedCount: document.getElementById('placed-count'),
            totalCount: document.getElementById('total-count'),
            statusMsg: document.getElementById('status-message'),
            allowRotation: document.getElementById('allow-rotation')
        };

        // --- THREE.JS GLOBALS ---
        let scene, camera, renderer, controls, cargoGroup;

        // --- INIT ---
        initThreeJS();
        animate();
        updateUIStats();

        // --- EVENT LISTENERS ---
        ui.containerSelect.addEventListener('change', (e) => {
            currentContainer = containerTypes[e.target.value];
            drawContainer();
            runPackingAlgorithm(); 
        });

        ui.allowRotation.addEventListener('change', () => {
            runPackingAlgorithm();
            showStatus('Yerleşim güncellendi');
        });

        document.getElementById('clear-list').addEventListener('click', () => {
            if(confirm('Liste temizlensin mi?')) {
                items = [];
                renderItemList();
                runPackingAlgorithm();
            }
        });

        ui.addItemForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const count = parseInt(document.getElementById('p-count').value);
            const baseItem = {
                name: document.getElementById('p-name').value,
                w: parseFloat(document.getElementById('p-width').value),
                h: parseFloat(document.getElementById('p-height').value),
                l: parseFloat(document.getElementById('p-length').value),
                weight: parseFloat(document.getElementById('p-weight').value),
                color: document.getElementById('p-color').value,
                vol: 0 // Hesaplanacak
            };
            baseItem.vol = baseItem.w * baseItem.h * baseItem.l;

            for(let i=0; i<count; i++) {
                items.push({ ...baseItem, id: Date.now() + Math.random().toString() });
            }

            renderItemList();
            runPackingAlgorithm();
            showStatus('Ürünler eklendi');
        });

        // --- CORE FUNCTIONS ---

        function showStatus(msg) {
            ui.statusMsg.innerText = msg;
            ui.statusMsg.style.opacity = '1';
            setTimeout(() => { ui.statusMsg.style.opacity = '0'; }, 2000);
        }

        // Listeyi Hacme Göre Sırala
        function autoOptimize() {
            // Büyük hacimli ve geniş tabanlıları öne al
            items.sort((a, b) => {
                const volA = a.w * a.h * a.l;
                const volB = b.w * b.h * b.l;
                return volB - volA; // Hacme göre büyükten küçüğe
            });
            renderItemList(); // Listeyi UI'da da güncelle
            runPackingAlgorithm();
            showStatus('Liste optimize edildi');
        }

        function updateVisualization() {
            runPackingAlgorithm();
        }

        // --- ALGORİTMA: CANDIDATE POINTS / ANCHOR SEARCH (DÖNDÜRME DESTEKLİ) ---
        // Bu algoritma, yerleştirilen her kutunun etrafında (sağ, üst, ön) yeni "aday noktalar" oluşturur.
        // Sıradaki kutu için bu aday noktaların hepsi taranır. Kutuya ve konteynere en iyi uyan (önce arkadakiler) seçilir.
        function runPackingAlgorithm() {
            // Temizlik
            while(cargoGroup.children.length > 0){ cargoGroup.remove(cargoGroup.children[0]); }
            placedItems = [];
            
            const contW = currentContainer.w;
            const contH = currentContainer.h;
            const contL = currentContainer.l;
            const allowRot = ui.allowRotation.checked;

            // Aday Noktalar Listesi (Başlangıç: 0,0,0)
            // {x, y, z}
            let candidates = [{x: 0, y: 0, z: 0}];

            items.forEach(item => {
                let bestCandidateIdx = -1;
                let bestOrientation = 0; // 0: Normal, 1: Rotated (Swap W & L)
                
                // Aday noktaları sırala:
                // Öncelik: Z (Arkadakiler), Y (Alttakiler), X (Soldakiler)
                // Bu sayede "boşlukları" önce doldururuz.
                candidates.sort((a, b) => {
                    if (a.z !== b.z) return a.z - b.z;
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });

                // Her bir aday noktayı dene
                for (let i = 0; i < candidates.length; i++) {
                    const c = candidates[i];
                    
                    // 1. Normal Oryantasyon Dene (W, L)
                    if (canPlace(c.x, c.y, c.z, item.w, item.h, item.l, placedItems, contW, contH, contL)) {
                        bestCandidateIdx = i;
                        bestOrientation = 0;
                        break; // İlk uygun yeri bulduk (First Fit)
                    }

                    // 2. Döndürülmüş Dene (L, W) -> Eğer izin veriliyorsa
                    if (allowRot) {
                        if (canPlace(c.x, c.y, c.z, item.l, item.h, item.w, placedItems, contW, contH, contL)) {
                            // Sadece normal sığmadıysa mı bunu seçelim? 
                            // First Fit mantığında normal sığmadıysa ve bu sığıyorsa harikadır.
                            // Eğer ikisi de sığıyorsa, yukarıdaki 'break' zaten normali seçti.
                            // Burada sadece normal sığmamışsa buraya düşeriz (veya loop devam eder).
                            bestCandidateIdx = i;
                            bestOrientation = 1;
                            break;
                        }
                    }
                }

                if (bestCandidateIdx !== -1) {
                    // Yerleştir
                    const c = candidates[bestCandidateIdx];
                    const w = bestOrientation === 0 ? item.w : item.l;
                    const l = bestOrientation === 0 ? item.l : item.w; // W ve L yer değiştirdi
                    const h = item.h;

                    // Görseli oluştur
                    createBox(item, c.x, c.y, c.z, w, h, l, contW, contL);
                    
                    // Kayıt altına al
                    placedItems.push({
                        x: c.x, y: c.y, z: c.z,
                        w: w, h: h, l: l,
                        rawItem: item
                    });

                    // Kullanılan adayı sil
                    candidates.splice(bestCandidateIdx, 1);

                    // YENİ ADAY NOKTALAR OLUŞTUR
                    // Bir kutu konduğunda 3 yeni potansiyel nokta oluşur:
                    // 1. Sağ üst köşe hizası (Right Anchor): (x + w, y, z)
                    // 2. Üst köşe hizası (Top Anchor): (x, y + h, z)
                    // 3. Ön köşe hizası (Front Anchor): (x, y, z + l)
                    
                    addCandidate(candidates, c.x + w, c.y, c.z, contW, contH, contL);
                    addCandidate(candidates, c.x, c.y + h, c.z, contW, contH, contL);
                    addCandidate(candidates, c.x, c.y, c.z + l, contW, contH, contL);
                }
            });

            updateUIStats();
        }

        function addCandidate(list, x, y, z, cW, cH, cL) {
            // Konteyner sınırları dışındaysa ekleme
            if (x >= cW || y >= cH || z >= cL) return;
            
            // Eğer bu nokta zaten başka bir kutunun İÇİNDEYSE ekleme
            for (let p of placedItems) {
                if (x >= p.x && x < p.x + p.w &&
                    y >= p.y && y < p.y + p.h &&
                    z >= p.z && z < p.z + p.l) {
                    return;
                }
            }

            // Zaten listede varsa ekleme (duplicate önle)
            const exists = list.some(p => Math.abs(p.x - x) < 0.1 && Math.abs(p.y - y) < 0.1 && Math.abs(p.z - z) < 0.1);
            if (!exists) {
                list.push({x, y, z});
            }
        }

        function canPlace(x, y, z, w, h, l, placedItems, cW, cH, cL) {
            // 1. Konteyner sınırları kontrolü
            // Küçük bir tolerans (epsilon) ekleyerek floating point hatalarını önleyelim
            const epsilon = 0.01;
            if (x + w > cW + epsilon) return false;
            if (y + h > cH + epsilon) return false;
            if (z + l > cL + epsilon) return false;

            // 2. Diğer kutularla çarpışma kontrolü
            // AABB (Axis-Aligned Bounding Box) Intersection
            const b1 = { x: x, y: y, z: z, w: w, h: h, l: l };

            for (let p of placedItems) {
                const b2 = { x: p.x, y: p.y, z: p.z, w: p.w, h: p.h, l: p.l };
                if (intersect(b1, b2)) return false;
            }

            return true;
        }

        function intersect(b1, b2) {
            // Kutular birbirine değiyorsa (örneğin biri 0-80, diğeri 80-160) kesişim sayılmaz.
            // Bu yüzden < ve > kullanıyoruz, <= değil.
            // Ancak floating point için biraz küçültülmüş collision box kullanmak daha güvenli.
            
            // Basit AABB
            return (
                b1.x < b2.x + b2.w &&
                b1.x + b1.w > b2.x &&
                b1.y < b2.y + b2.h &&
                b1.y + b1.h > b2.y &&
                b1.z < b2.z + b2.l &&
                b1.z + b1.l > b2.z
            );
        }

        // --- RENDER HELPERS ---
        function createBox(item, x, y, z, w, h, l, cW, cL) {
            // ThreeJS koordinatlarına çeviri
            const geometry = new THREE.BoxGeometry(w, h, l);
            const material = new THREE.MeshStandardMaterial({ 
                color: item.color, 
                roughness: 0.6,
                metalness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Kenar çizgileri (Daha belirgin)
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.5, transparent: true }));
            mesh.add(line);

            // Pozisyon
            // ThreeJS merkezi koordinat alır, bizim algoritmamız sol-alt-arka köşe (0,0,0) verir.
            // Konteynerin sol-alt-arka köşesini ThreeJS dünyasında bulalım:
            // Konteyner width (X): -cW/2
            // Konteyner floor (Y): 0 (drawContainer'da zemin -2, yüzey 0)
            // Konteyner length (Z): -cL/2

            const pivotX = -cW / 2;
            const pivotY = 0; 
            const pivotZ = -cL / 2;

            mesh.position.set(
                pivotX + x + w / 2,
                pivotY + y + h / 2,
                pivotZ + z + l / 2
            );

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Animasyonlu giriş
            mesh.scale.set(0.1, 0.1, 0.1);
            let sc = 0.1;
            function grow() {
                if(sc < 1) {
                    sc += 0.15;
                    if(sc > 1) sc = 1;
                    mesh.scale.set(sc,sc,sc);
                    requestAnimationFrame(grow);
                }
            }
            grow();

            cargoGroup.add(mesh);
        }

        function drawContainer() {
            const oldContainer = scene.getObjectByName("containerFrame");
            if (oldContainer) scene.remove(oldContainer);
            const oldFloor = scene.getObjectByName("containerFloor");
            if (oldFloor) scene.remove(oldFloor);

            const w = currentContainer.w;
            const h = currentContainer.h;
            const l = currentContainer.l;

            // Zemin
            const floorGeo = new THREE.BoxGeometry(w, 4, l);
            const floorMat = new THREE.MeshPhongMaterial({ color: 0x64748b });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.set(0, -2, 0); 
            floor.name = "containerFloor";
            floor.receiveShadow = true;
            scene.add(floor);

            // Çerçeve
            const boxGeo = new THREE.BoxGeometry(w, h, l);
            const edges = new THREE.EdgesGeometry(boxGeo);
            const frame = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xef4444, linewidth: 2 }));
            frame.position.set(0, h/2, 0);
            frame.name = "containerFrame";
            scene.add(frame);
        }

        // --- UI UPDATES ---
        function renderItemList() {
            ui.listContainer.innerHTML = '';
            if (items.length === 0) {
                ui.listContainer.innerHTML = `<div class="text-center text-slate-400 mt-10 text-sm flex flex-col items-center gap-2">
                    <i class="fa-solid fa-clipboard-list text-2xl opacity-20"></i><span>Liste boş.</span></div>`;
                return;
            }

            items.forEach((item, index) => {
                const el = document.createElement('div');
                el.className = 'draggable-item bg-white p-2 rounded border border-slate-200 shadow-sm flex items-center justify-between text-sm group hover:border-blue-300 relative';
                el.draggable = true;
                el.dataset.index = index;
                
                el.innerHTML = `
                    <div class="flex items-center overflow-hidden pointer-events-none">
                        <div class="text-slate-300 px-2 flex-shrink-0">
                            <i class="fa-solid fa-grip-vertical"></i>
                        </div>
                        <div class="w-3 h-8 rounded-l mr-2 flex-shrink-0" style="background-color: ${item.color}"></div>
                        <div class="truncate">
                            <div class="font-medium text-slate-700 truncate text-xs">${item.name}</div>
                            <div class="text-[10px] text-slate-400">${item.w}x${item.l}x${item.h} | ${item.weight}kg</div>
                        </div>
                    </div>
                    <button onclick="removeItem(${index})" class="text-slate-300 hover:text-red-500 p-2 transition-colors z-10 cursor-pointer">
                        <i class="fa-solid fa-trash-can"></i>
                    </button>
                `;
                
                // Drag Events
                el.addEventListener('dragstart', dragStart);
                el.addEventListener('dragover', dragOver);
                el.addEventListener('drop', dragDrop);
                el.addEventListener('dragenter', dragEnter);
                el.addEventListener('dragleave', dragLeave);
                
                ui.listContainer.appendChild(el);
            });
        }

        function updateUIStats() {
            let totalW = 0;
            let totalV = 0;
            
            placedItems.forEach(i => {
                totalW += i.rawItem.weight;
                totalV += (i.w * i.h * i.l);
            });

            // Container Hacim
            const cVol = currentContainer.w * currentContainer.h * currentContainer.l;
            const fillRate = (totalV / cVol) * 100;

            ui.weightDisplay.innerText = `${totalW.toLocaleString()} kg`;
            ui.volDisplay.innerText = `${(totalV / 1000000).toFixed(2)} m³`;
            ui.fillDisplay.innerText = `%${fillRate.toFixed(1)} Doluluk`;
            
            ui.placedCount.innerText = placedItems.length;
            ui.totalCount.innerText = items.length;

            if(totalW > currentContainer.maxWeight) {
                ui.weightDisplay.parentElement.classList.replace('bg-slate-700', 'bg-red-600');
            } else {
                ui.weightDisplay.parentElement.classList.replace('bg-red-600', 'bg-slate-700');
            }
        }

        function removeItem(index) {
            items.splice(index, 1);
            renderItemList();
            runPackingAlgorithm();
        }

        // --- DRAG DROP FUNCTIONS ---
        function dragStart(e) {
            dragStartIndex = +this.dataset.index;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        function dragOver(e) { 
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';
        }
        function dragEnter(e) { 
            e.preventDefault();
            this.classList.add('border-blue-500'); 
        }
        function dragLeave() { this.classList.remove('border-blue-500'); }
        
        function dragDrop(e) {
            e.stopPropagation(); // Güvenlik
            const dragEndIndex = +this.dataset.index;
            if(dragStartIndex !== dragEndIndex) {
                swapItems(dragStartIndex, dragEndIndex);
            }
            this.classList.remove('border-blue-500');
            document.querySelectorAll('.dragging').forEach(d => d.classList.remove('dragging'));
        }
        
        function swapItems(from, to) {
            const item = items[from];
            items.splice(from, 1);
            items.splice(to, 0, item);
            renderItemList();
            runPackingAlgorithm(); // Sıra değişince yerleşim otomatik güncellenir
        }

        // --- THREE JS SETUP ---
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe2e8f0);
            scene.fog = new THREE.Fog(0xe2e8f0, 2000, 5000);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
            camera.position.set(1000, 800, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(500, 1000, 500);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            cargoGroup = new THREE.Group();
            scene.add(cargoGroup);

            drawContainer();

            window.addEventListener('resize', () => {
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>